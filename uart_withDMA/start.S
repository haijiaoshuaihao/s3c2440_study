
.text
.global _start

_start:
	b reset
	ldr pc, und_addr
	ldr pc, swi_addr
    b halt/*Vector 0x0C: prefetch abort*/ 
    b halt/*Vector 0x10: data abort*/ 
    b halt/*Vector 0x14: reserved*/ 
    ldr pc, irq_addr /*Vector 0x18: irq*/ 
    b halt /*Vector 0x1C: fiq*/ 
     




und_addr:
	.word do_und

swi_addr:
	.word do_swi

irq_addr:
	.word do_irq

do_und:
    /*此处有C函数需要设立好堆栈，这个堆栈是UND异常特有的*/
	ldr sp, =0x34000000
	/*保存现场,需要保存通用寄存器R0-R12以及发生异常时指令的值*/
	stmdb sp!, {r0-r12,lr}
	/* 含义：sp = sp - 4，先压lr，sp = lr（即将lr中的内容放入sp所指的内存地址）。
	sp = sp - 4，再压r12，sp = r12。sp = sp - 4，再压r11，sp = r11......
	sp = sp - 4，最后压r0，sp = r0。 */
	/* 处理und异常*/
	mrs r0 ,cpsr
	ldr r1, =und_string
	bl printException/*如果nand启动 这个函数位于4K之外 这个函数不会正确执行*/
    /*恢复现场*/
	ldmia sp!, {r0-r12,pc}^ /*尖括号把SPSR恢复到CPSR*/
und_string:
	.string "undefined instruction exception"

.align 4

do_swi:
    /*此处有C函数需要设立好堆栈，这个堆栈是UND异常特有的*/
	ldr sp, =0x33e00000
	/*保存现场,需要保存通用寄存器R0-R12以及发生异常时指令的值*/
	stmdb sp!, {r0-r12,lr}
	/* 含义：sp = sp - 4，先压lr，sp = lr（即将lr中的内容放入sp所指的内存地址）。
	sp = sp - 4，再压r12，sp = r12。sp = sp - 4，再压r11，sp = r11......
	sp = sp - 4，最后压r0，sp = r0。 */

    mov r4, lr

	/* 处理und异常*/
	mrs r0 ,cpsr
	ldr r1, =swi_string
	bl printException/*如果nand启动 这个函数位于4K之外 这个函数不会正确执行*/
    
	sub r0 ,r4, #4
	bl printSWIVal
	
    /*恢复现场*/
	ldmia sp!, {r0-r12,pc}^ /*尖括号把SPSR恢复到CPSR*/
swi_string:
	.string "swi instruction exception"

.align 4

do_irq:
    /*此处有C函数需要设立好堆栈，这个堆栈是UND异常特有的*/
	ldr sp, =0x33d00000
	/*保存现场,需要保存通用寄存器R0-R12以及发生异常时指令的值*/
	sub lr, lr, #4
	stmdb sp!, {r0-r12,lr}
	/* 含义：sp = sp - 4，先压lr，sp = lr（即将lr中的内容放入sp所指的内存地址）。
	sp = sp - 4，再压r12，sp = r12。sp = sp - 4，再压r11，sp = r11......
	sp = sp - 4，最后压r0，sp = r0。 */
	/* 处理und异常*/
	
	bl handle_irq_c/*如果nand启动 这个函数位于4K之外 这个函数不会正确执行*/
    /*恢复现场*/
	ldmia sp!, {r0-r12,pc}^ /*尖括号把SPSR恢复到CPSR*/

.align 4

reset:
	/* 关闭看门狗 */
	ldr r0, =0x53000000
	ldr r1, =0
	str r1, [r0]

	/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */
	/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */
	ldr r0, =0x4C000000
	ldr r1, =0xFFFFFFFF
	str r1, [r0]

	/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */
	ldr r0, =0x4C000014
	ldr r1, =0x5
	str r1, [r0]

	/* 设置CPU工作于异步模式 */
	mrc p15,0,r0,c1,c0,0
	orr r0,r0,#0xc0000000   //R1_nF:OR:R1_iA
	mcr p15,0,r0,c1,c0,0

	/* 设置MPLLCON(0x4C000004) = (92<<12)|(1<<4)|(1<<0) 
	 *  m = MDIV+8 = 92+8=100
	 *  p = PDIV+2 = 1+2 = 3
	 *  s = SDIV = 1
	 *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M
	 */
	ldr r0, =0x4C000004
	ldr r1, =(92<<12)|(1<<4)|(1<<0)
	str r1, [r0]

	/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定
	 * 然后CPU工作于新的频率FCLK
	 */
	
	

	/* 设置内存: sp 栈 */
	/* 分辨是nor/nand启动
	 * 写0到0地址, 再读出来
	 * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动
	 * 否则就是nor启动
	 */
	mov r1, #0
	ldr r0, [r1] /* 读出原来的值备份 */
	str r1, [r1] /* 0->[0] */ 
	ldr r2, [r1] /* r2=[0] */
	cmp r1, r2   /* r1==r2? 如果相等表示是NAND启动 */
	ldr sp, =0x40000000+4096 /* 先假设是nor启动 */
	moveq sp, #4096  /* nand启动 */
	streq r0, [r1]   /* 恢复原来的值 */

	bl sdram_init
	//bl sdram_init2	 /* 用到有初始值的数组, 不是位置无关码 */

	/* 重定位text, rodata, data段整个程序 */
	bl copy2sdram

	/* 清除BSS段 */
	bl clean_bss

    /*把CPU设置为USR模式*/	
	mrs r0, cpsr
	bic r0, r0, #0xf
	bic r0, r0, #(1<<7) /*清除I位 使处理器可以产生中断*/
	msr cpsr, r0

	ldr sp, =0x33f00000


	ldr pc, =sdram
sdram:	
	bl uart0_init
    

    mrs r0, cpsr
	orr r0, r0, #0x40000000
	msr cpsr, r0

und_code:
	.word 0xDEADC0DE
	swi 0x123

	
    
	//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */
	ldr pc, =main  /* 绝对跳转, 跳到SDRAM */

halt:
	b halt
	
